# vue 部分

## 1. 介绍下 MVVM（数据的双向绑定）

* M：model 数据模型
* V：view 界面
* MV:作为桥梁负责沟通 view 跟 model
* 只关心数据的流传，减少强耦合性。最关键的就是数据的双向绑定
* 关键步骤：
* 1.实现数据监听器 Observer,用 object.defineProperty()重写数据的 get/set。值更新就在 set 中通知订阅者更新数据。
* 2.实现模板编译 compile,深度遍历 dom 树，对每个元素节点的指令模板替换数据以及订阅数据。
* 3.实现 watch 用于连接 Observer 和 compile,能够订阅并接受每一个属性的变动的通知，执行指令绑定的相应的回调函数，从而更新数据。
* mvc 和 mvvm 其实区别并不大。都是一种设计思想。主要是 mvc 中 Controller 演变成 mvvm 中的 viewModel，mvvm 主要解决了 mvc 中大量的 dom 操作使页面渲染性能降低。

## 2. eventBus vuex

* 原理：eventBus 解决了兄弟组件之间事件传递问题，本质是订阅发布者模式，从而摆脱了兄弟之间需要父子组件转而传递的复杂。还有一种方法是 vuex 数据流，单一状态数，rootState 树根
* 名词，专车，订阅者跟发布者都引用专车，这个 vue 实例，来完成订阅发布者。emit（发布） on（订阅一个组件）
* npm 包 vue-event-proxy
* vuex 是将数据单独的抽离出来，一种状态管理工具，它借鉴的是 flux,redux 的基本思想，将状态抽离到全局形成一个 store

## 3. watch

* 对属性进行监听，允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到结果前，设置中间状态

## 4. vue 的双向数据绑定实现原理

* 1.核心就是数据劫持+发布/订阅者模式：vue 使用的是 Object.defineProperty()通过监听他的 get/set 事件，监听对数据的操作，从而触发数据同步
* Object.defineProperty 缺陷的：
  * 1.只能对属性进行数据劫持，并且需要深度遍历整个对象
  * 2.对于数组不能监听数据的变化，而 proxy 原生支持监听数组的变化，并且可以直接对整个对象进行拦截，所有 vue 下个版本中用 proxy 替换 object.defineProperty

## 5. nextTick 原理

## 6. 生命周期函数

* new Vue（创建一个 Vue 对象） --> beforeCreate --> observer Data(开始监听 data 对象数据变化) --> init event(vue 内部初始化事件) -->created() --> compile(编译模板，把 data 里面的数据和模板生成 html) -->beforeMount（还没有生成 HTML 到元素上） --> mounted（挂载完成，也就是模板中的 html 渲染到了 html 页面中）--> beforeUpate(Virtual Dom) --> updated --> beforeDestory -->destoryed
* 1.ajax 请求最好放在 created 里面，页面可以访问到 this 了
* 2.关于 dom 的操作要放在 mounted 里面，在 mounted 前面还没有生成 dom
* 3.每次进入/离开组件都要做一些事情，用什么钩子函数：
  * 不缓存：进入的时候可以用 created 和 mounted 钩子，离开的时候可以使用 beforedDestory(可以访问 this)和 destoryed
  * 缓存：缓存了组件之后，再次进入组件不会触发 beforeCreate，created，beforeMount，mounted，如果你想每次进入组件都做一些事情的话，你可以放在 activated 进入缓存组件的钩子中

## 7. keep-alive

* 在被 keep-alive 包含的组件/路由,会多出两个生命周期：activated 和 deactivated
* actived 在组件第一次渲染时会被调用，之后再每次缓存组件被激活时调用，调用机制：第一次进入缓存路由/组件，在 mounted 后面，beforeRouteEnter 守卫传给 next 的回调函数之前调用

## 8. vue 的 spa 如何优化加载速度

* 1.减少入口文件的体积
* 2.静态资源本地缓存
* 3.开启 gzip 压缩
* 4.使用 ssr，nuxt.js

## 9. 模块化

* 基本概念:
  * 1.在 js 中，一个模块就是实现特定功能的文件（js）文件
  * 2.遵循模块的机制，想要什么就加载什么模块
  * 3.模块化开发需要遵循规范
* js 实现模块化规范
  * 1.AMD 浏览器 requirejs 模块被异步加载，模块加载不影响后面语句的运行，默认使用 baseURL+paths 的路径解析方式
  * 2.CommonJS nodejs
  * 3.ES6 的 import/export
  * 4.CMD 浏览器端
* 解决的问题：
  * 1.命名冲突
  * 2.文件依赖
  * 3.模块的复用
  * 4.统一规范和开发方式

## 10. 谈谈 vue 和 react 组件化的思想

* 1.我们在各个页面开发的时候，会产生很多重复的功能，比如，element 中的 xxx，像这种纯粹非页面的 UI，便成为我们常用 UI 组件，最初的前端组件也就仅仅值得是 UI 组件
* 2.随着业务逻辑变得越来越多时，我们就想要我们的组件可以处理很多事，这就是我们常说的组件化，这个组件就不是 UI 组件了，而是包含具体业务的业务组件
* 3.这种开发思想就是分而治之。最大程度降低开发难度和维护成本的效果，并且可以多人协作，每人写不同的组件，最后像搭积木一样把它构成一个页面

## 11.vue 的依赖手机和 watch 原理
