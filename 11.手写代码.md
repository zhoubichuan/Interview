### 1.手动实现一个 bind（原理通过 call、apply）

* 一句话概况
  * 1.bind()返回一个新函数，并不会立即执行
  * 2.bind 的第一个参数将作为他运行时的 this,之后的一系列参数将会在传递的实参前传入作为他的参数
  * 3.bind 返回函数作为构造函数，就是可以 new 的，bind 时指定 dethis 值就会消失，但传入的参数依然生效

```
Function.prototype.bind=function(obj,arg){
    var arg=Array.prototype.slice.call(arguments,1)
    var context=this
    var bound=funciton(newArg){
        arg=arg.concat(Array.prototype.slice.call(newArg))
        return context.apply(obj,arg)
    }
}
var F=function(){
//在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程
}
F.prototype=context.prototype
bound.prototype=new F()
return bound
```

### 2.ajax（异步的 javascript 和 xml）

* ajax 原理：相当于在用户和服务器之间加一个中间层（ajax 引擎），使用户操作与服务器响应异步化

- 优点：在不刷新整个页面的前提下与服务器通信维护数据；可以把前端服务器的任务转嫁到客户端来处理；减轻服务器负担，节省宽带
- 劣势：不支持 back，对搜索引擎的支持比较弱，不容易调试
- 怎么解决呢：通过 location.hash 值来解决 ajax 过程中导致的浏览器前进后退按钮失效问题
- 怎么解决以前被人们常遇到的重复加载问题。主要比较前后的 hash 值，看其是否相等，再判断是否触发 ajax

```
function getDate(url){
    var xhr= new XMLHttpRequest()
    xhr.open('get',url,true)
    xhr.send()
    xhr.onreadystatechange=function(){
        if(xhr.readyState ==4&& xhr.status==200){
            console.log(xhr.responseText)
        }
    }
}
Promise(getDate(url)).resolve(data=>data)
```

* ajax 状态码
  * 0 （未初始化）还没有调用 send()方法
  * 1 （载入）已调用 send()方法，正在发送请求
  * 2 （载入完成）send()方法执行完毕
  * 3 （交互）正在解析相应的内容
  * 4 （完成）响应内容解析完成，可以在客户端调用了

### 3.函数节流

```
functio throttle(func,wait){
    var timeout;
    var previous=0;
    return function(){
        context = this
        args=arguments
        if(!timeout){
            timeout=setTimeout(()=>{
                timeout=null
                func.apply(context,args)
            },wait)
        }
    }
}
```

### 4.函数防抖

```
function debounce(func,wait){
    var timeout;
    return function(){
        var context= this
        var args= arguments
        clearTimeout(timeout)
        timeout= setTimeout(()=>{
            func.apply(contenxt,args)
        },wait)
    }
}
```

### 5.实现一个函数 clone,可以对 javascirpt 中的 5 种主要的数据类型（包含 number，string，object，array，boolean）进行复制

```
Object.prototype.clone= function(){
    //对象的深拷贝 获取对应的构造函数 [] 或者{}
    var newObject=this.constructor===Array?[]:{}
    //遍历对象的
    for(let a in this){
        newObject[a]=typeof this[a]==='object'?this[a].clone():this[a]
    }
    return newObject
}
```

### 6.实现一个简单的 promise

```
class Promise{
    constructor(executor){
        this.status='pending'
        this.value=undefined
        this.reason=undefined
        this.onResolvedCallbacks=[]
        this.onRejectedCallbacks=[]
        let resolve=(value)=>{
            if(this.status==='pending'){
                this.status='resolve';
                this.value=value
                this.onResolvedCallbacks.forEach(fn=>fn())
            }
        }
        try{
            executor(resolve,reject)
        }catch(err){
            reject(err)
        }
    }
    then (onFullFilled,onRejected){
       if(this.status ==='resolved'){
           onFullFilled(this.value)
       }
       if(this.status==='rejected'){
           onRejected(this.reason)
       }
       if(this.status==='pending'){
           this.onResolvedCallbacks.push(()=>{
               onFullFilled(this.value)
           })
           this.onRejectedCallbacks.push(()=>{
               onRejected(this.reason)
           })
       }
    }
}
const p = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('hello world')
    },100)
})
p.then((data)=>{
    console.log(data)
},error=>{
    console.log(error)
})
```

### 7.发布订阅模式（观察者模式）

```
var event=[]
event.clientList=[]
event.listen=function(fn){
    this.clientList.push(fn)
}
event.trigger=function(){
    for(var i = 0;i<this.clientList.length;i++){
        var fn= this.clientList[i]
        fn.apply(this,arguments)
    }
}
event.listen(function(time){
    console.log('正式上班时间为：'+time)
})
event.trigger('2018/7')
```

### 8.手动写一个 node 服务器

    ```
    const http = require('http';
    const fs = require('fs');
    const server = http.createServer((req,res)=>{
    if(req.url == '/'){
    const indexFile = fs.createReadStream('./index.html');
    req.writeHead(200,{'context-Type':'text/html;chartset=utf8'});
    indexFile.pipe(res);

        }

    })
    server.listen(8080);

```

```
