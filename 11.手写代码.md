### 1.手动实现一个 bind（原理通过 call、apply）

* 一句话概况
  * 1.bind()返回一个新函数，并不会立即执行
  * 2.bind 的第一个参数将作为他运行时的 this,之后的一系列参数将会在传递的实参前传入作为他的参数
  * 3.bind 返回函数作为构造函数，就是可以 new 的，bind 时指定 dethis 值就会消失，但传入的参数依然生效

```
Function.prototype=function(){
    var self=this
    var context= [].shift.call(arguments)
    var args=[].slice.call(arguments)
    return function(){
        return self.apply(contxt,[].concat.call(args,[].slice.call(arguments)))
    }
}
```

```
Function.prototype=function(){
    var context=[].shift.call(arguments)
    var args=arguments
    return ()=>
    this.call(context,...args,...arguments)
}
```

### 2.ajax（异步的 javascript 和 xml）

* ajax 原理：相当于在用户和服务器之间加一个中间层（ajax 引擎），使用户操作与服务器响应异步化

- 优点：在不刷新整个页面的前提下与服务器通信维护数据；可以把前端服务器的任务转嫁到客户端来处理；减轻服务器负担，节省宽带
- 劣势：不支持 back，对搜索引擎的支持比较弱，不容易调试
- 怎么解决呢：通过 location.hash 值来解决 ajax 过程中导致的浏览器前进后退按钮失效问题
- 怎么解决以前被人们常遇到的重复加载问题。主要比较前后的 hash 值，看其是否相等，再判断是否触发 ajax

```
let getDate = (method, url, content) = >
new Promise((resolve, reject) = > {
  letxhr = new XMLHttpRequest()
  xhr.open(method, url)
  xhr.send(content)
  xhr.onreadystatechange = () = > {
    if (xhr.readyState === 4 && xhr.status === 200) {
      resolve(xhr.response)
    }
  }
})
```

* ajax 状态码
  * 0 （未初始化）还没有调用 send()方法
  * 1 （载入）已调用 send()方法，正在发送请求
  * 2 （载入完成）send()方法执行完毕
  * 3 （交互）正在解析相应的内容
  * 4 （完成）响应内容解析完成，可以在客户端调用了

### 3.函数节流

```
function throttle(fn, wait) {
    var timer
    return function () {
        var context = this
        var args = arguments
        if (!timer) {
            timer = setTimeout(function () {
                timer = null
                fn.apply(context, args)
            }, wait)
        }
    }
}
window.onresize = throttle(function () {
    console.log(1);
}, 500);
```

### 4.函数防抖

```
function debounce(func,wait){
    var timeout;
    return function(){
        var context= this
        var args= arguments
        clearTimeout(timeout)
        timeout= setTimeout(()=>{
            func.apply(contenxt,args)
        },wait)
    }
}
```

### 5.实现一个函数 clone,可以对 javascirpt 中的 5 种主要的数据类型（包含 number，string，object，array，boolean）进行复制

```
Object.prototype.clone= function(){
    //对象的深拷贝 获取对应的构造函数 [] 或者{}
    var newObject=this.constructor===Array?[]:{}
    //遍历对象的
    for(let a in this){
        newObject[a]=typeof this[a]==='object'?this[a].clone():this[a]
    }
    return newObject
}
```

### 6.实现一个简单的 promise

```
class Promise {
  constructor(executor) {
    this.status = "pending";
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    let resolve = value => {
      if (this.status === "pending") {
        this.status = "resolve";
        this.value = value;
        this.onResolvedCallbacks.forEach(fn => fn());
      }
    };
    let reject = reason => {
      if (this.status === "pending") {
        this.status = "reject";
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }
  then(onFullFilled, onRejected) {
    if (this.status == "resolved") {
      onFullFilled(this.value);
    }
    if (this.status === "rejected") {
      onRejected(this.reason);
    }
    if (this.status === "pending") {
      this.onResolvedCallbacks.push(() => {
        onFullFilled(this.value);
      });
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason);
      });
    }
  }
}
const p = new Promise((resolve,reject)=>{
    setTimeout(()=>{
        resolve('hello world')
    },100)
})
p.then((data)=>{
    console.log(data)
},error=>{
    console.log(error)
})
```

### 7.发布订阅模式（观察者模式）

```
var event=[]
event.clientList=[]
event.listen=function(fn){
    this.clientList.push(fn)
}
event.trigger=function(){
    for(var i = 0;i<this.clientList.length;i++){
        var fn= this.clientList[i]
        fn.apply(this,arguments)
    }
}
event.listen(function(time){
    console.log('正式上班时间为：'+time)
})
event.trigger('2018/7')
```

### 8.手动写一个 node 服务器

```
const http = require("http");
const fs = requier("fs");
const server = http.createServer((req, res) => {
  if ((req.url = "/")) {
    const indexFile = fs.createReadStream("./index.html");
    req.writeHead(200, { "content-Type": "text/html;charset=urf8" });
    indexFile.pipe(res);
  }
});
server.listen(3000);
```
