---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 六.设计模式

## 1.SOLID

- 单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因
- 开放封闭原则：核心的思想是软件实体（类、模块、函数等）是可扩展的、但不可修改的。也就是说，对扩展是开放的，而对修改时封闭的
- 里氏替换原则
- 接口隔离原则
- 依赖反转原则

## 2.面向对象的

- 封装
- 继承
- 多态

## 3.设计模式

### 3.1 创建型

- 工厂模式
- 抽象工厂模式
- 单例模式
- 原型模式
- 建造者模式

### 3.2 结构型

- 适配器模式
- 装饰器模式
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 亨元模式

### 3.3 行为型

- 观察者模式
- 命令模式
- 策略模式
- 模板方法模式
- 职责链模式
- 命令模式 ß

## 8. 什么是原型链

- 对于 object 来说，可以通过**proto**找到一个原型对象，在该对象中定义了很多函数让我们来使用
- 原型链是一种机制，指的是 javascript 每个对象包括原型对象都有一个内置**proto**属性指向创建它的函数对象的原型对象，即 prototype 属性
- 函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针**proto**；该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似；因此可以利用**proto**一直指向 object 的原型对象上，而 object 原型对象用 object.prototype=null 表示原型链顶端。如此形成了 js 的原型链继承。同时所有的 js 对象都有 object 的基本方法。

## 9. 类的创建和继承

- 1.原型链继承
- 2.构造函数继承
- 3.组合继承
- 4.原型式继承
- 5.寄生式继承
- 6.寄生组合继承
- 7.混合继承
- 8.es6 继承

### 1·原型链继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.portotype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.name = "child";
}
Child.prototype = new Parent();
Child.prototype.getChildName = function () {
  return this.name + 1;
};
var child = new Child();
console.log(child.getParentName());
```

### 2.构造函数继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.name = "child";
  Parent.call(this);
}
Child.prototype.getChildName = function () {
  return this.name + 1;
};
var child = new Child();
console.log(child.parentName);
```

### 3.组合继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.name = "child";
  Parent.call(this);
}
Child.prototype = new Parent();
Child.prototype.getChildName = function () {
  return this.name + 1;
};
var child = new Child();
console.log(child.getParentName());
console.log(child.parentName);
```

### 4.原型式继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function object(obj) {
  function F() {}
  F.prototype = obj;
  return new F();
}
var child = object(new Parent());
child.childName = "child";
child.getChildName = function () {
  this.childName + 1;
};
console.log(child.getChildName());
```

### 5.寄生式继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.portotype.getParentName = function () {
  return this.parentName + 1;
};
function createAnother(original) {
  var clone = Object(original);
  clone.childName = "child";
  clone.getChildName = function () {
    return this.childName + 1;
  };
  return clone;
}
var child = createAnother(new Parent());
child.prototype = new Parent();
console.log(child.parentName);
```

### 6.寄生组合继承

```js
function inheritPrototype(c, p) {
  var prototype = Object.create(p.ptototype);
  prototype.constructor = c;
  c.prototype = prototype;
}
function Parent() {
  this.parentName = "parent";
}
Parent.prototype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.childName = "child";
  Parent.call(this);
}
inheritPrototype(Child, Parent);
Child.prototype.getChildName = function () {
  return this.childName + 1;
};
var child = new Child();
console.log(child.parentName);
console.log(child.getParentName());
```

### 7.混合式继承

```js
function Parent() {
  this.parentName = "parent";
}
Parent.portotype.getParentName = function () {
  return this.parentName + 1;
};
function Child() {
  this.name = "child";
}
Child.prototype.getChildName = function () {
  return this.name + 1;
};
function MyClass() {
  Parent.call(this);
  Child.call(this);
}
MyClass.prototype = Object.create(Parent.prototype);
Object.assign(MyClass.prototype, Child.prototype);
MyClass.prototype.constructor = MyClass;
var child = new MyClass();
console.log(child.getParentName());
```

### 8.es6 中继承

```js
class Parent {
  constructor() {
    this.parentName = "parent";
  }
  getParentName() {
    return this.parentName + 1;
  }
}
class Child extends Parent {
  constructor() {
    super();
    this.childName = "child";
  }
  getChildName() {
    return this.childName + 1;
  }
}
var child = new Child();
console.log(child.getChildName());
```

## 11. 观察者模式

- 在软件开发设计找那个是一个对象（subject）,维护一系列依赖他的对象（observer）,当任何状态发生改变自动通知他们。强依赖关系
- 简答理解：数据发生改变是，对应的处理函数酒就会自动执行。一个 subjet，用来维护 observers，为某些 event 来通知（notify）观察者

## 12.发布-订阅者和观察者模式的区别

- 它定义了一种一对多的关系，可以使多个观察者对象对一个主体对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到

- 两者的区别：
  - 1.观察者模式中，观察者知道 subject，两者是相关联的，而发布订阅者只有通过信息代理进行通信
  - 2.在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反
  - 3.观察者大部分是同步的，比如事件的触发，subject 就会调用观察者的方法，而发布订阅者大多数是异步的
  - 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式
