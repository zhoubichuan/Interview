---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 四.前端安全
## 4.XSS 攻击有哪些类型

- 存储型
- 反射型
- DOM 型

## 5.如何防御 XSS 攻击

- 输入检查
- 设置 httpOnly
- 开启 CSP

## 6. 跨域

### 什么是跨域

- 同源策略：协议，端口，域名要相同
- 由于浏览器同源策略，凡是发送请求 url 的协议、域名、端口三者之间任意一种与当前页面地址不同即为跨域。

协议不同：
http 与 https

端口不同：
localhost:8080 与 localhost:3000

域名不同：
huawei.com 与 consumenr.huawei.com

### 跨域的十种方式

- 1.降级浏览器
- 2.jsonp
- 3.cors
- 4.node 中间件：proxy-middlewire
- 5.nginx：配置代理服务将后端请转发给前端
- 6.websockit:是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。
- 7.postmessage:h5 跨域方法 frame.contentWindow.postMessage,e.data;e.data,e.source.postMesage
- 8.localhost.hash:c 页面动态创建 b 页面，请求里面有参数，b 页面 window.parent.parent.location.hash=location.hash,a 通过 location.hash 拿到参数
- 9.document.name：proxy 一个空的代理页面，被访问的页面动态切换 iframe 页面域名，name 没有消失，frame.contentWindow.name,window.name
- 10.document.domain:主域名相同，docuemnt.domain 强制设置主域，freame.contentWindow,window.parent

## 18. 图片的懒加载和预加载

### 预加载：

提前加载图片，当用户需要查看时可以直接从本地缓存中渲染

为什么要使用预加载：在网页加载之前，对一些主要内容进行加载，减少等待时间，给用户提供更好的体验；否则，如歌一个页面的内容过于庞大，会出现留白。

- 解决留白的方法：
  - 1.  预加载
  - 2.  使用 svg 占位图片，将一些结构快速搭建起来，等请求的数据来了之后，替换当前的占位符
- 实现预加载的方法：
  - 1.  使用 html 标签
  - 2.  使用 Image 标签
  - 3.  使用 XMLHTTPRequest 对象，但会精细控制预加载过程；

### 懒加载：

客户端优化，减少 http 请求和延迟请求数量

- 提升用户体验
- 减少无效资源的加载
- 防止并发加载资源过多会阻塞 js 的加载，影响网站的正常使用
- 原理：首先将页面上的图片的 src 属性设置为空字符串，而图片的真路径则设置带 data-original 属性中；当页面滚动的时候去监听 scroll 事件，在 scroll 事件的回调中，判断我们的懒加载的图片是否进入可视区域；如果图片在可视区域将图片的 src 属性设置为 data-original 的值，这样就可以实现延迟加载。
## 1.XSS

> 什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP?

XSS ：持久性和非持久型

持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。

这种情况如果前后端没有做好防御的话，这段评论就会被储存到数据库中，这样每个打开该页面的用户都会被攻击到。

如果页面需要 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行。

但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。

对于 XSS 攻击来说，通常有两种方式可以用来防御。
**转义字符**
首先，对于用户的输入应该是永远不信任的。最普通的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。

但是对于显示富文本来说，显然不能通过上面的办法来转义所有的字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐白名单的方式。

**CSP**
CSP 本质就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。

通常可以通过两种方式来开启 CSP:

1.设置 HTTP Header 中的`Content-Security-Policy`

2.设置`meta`标签的方式`<meta http-equiv="Content-Securiry-Policy">`

这里以设置 HTTP Header 来举例

- 只允许加载本站资源

```js
Content-Security-Policy:default-src 'self'
```

- 只允许加载 HTTPS 协议图片

```
Content-Security-Policy:img-src https://*
```

- 允许加载任何来源框架

```js
Content-Security-Policy:child-src 'none'
```

对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。

## 2.CSRF

> 什么是 CSRF 攻击?如何防范 CSRF 攻击?

CSRF 中文名为跨站请求伪造。原理即使攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。

举个例子，假如网站中有一个通过`GET`请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口。

```js
<img src="http://www.domai.com/xxx?comment='attack'">
```

那么你也是否会想到使用`POST`方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全，攻击者同样可以诱导用户进入某个页面，在页面个中通过表单提交`POST`请求。
**如何防御**

防范 CSRF 攻击可以遵循以下几种规则：

1、Get 请求不对数据进行修改

2、不让第三方网站访问到用户 Cookie

3、阻止第三方网站请求接口

4、请求时附带验证信息，比如验码或者 Token

**SameSite**

可以对 Cookie 设置`SameSite`属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

**验证 Referer**

对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的

**Token**

服务器下发一个随机 Token,每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

## 3.点击劫持

> 什么是点击劫持？如何防范点击劫持？

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过`iframe`嵌套的方式嵌入自己的网页中，并将`iframe`设置为透明，在页面中透出一个按钮诱导用户点击。

对于这种攻击方式，推荐防御的方法有两种。
**X-FRAME-OPTIONS**

`X-FRAME-OPTIONS`是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头就是为了防御用`iframe`嵌套的点击劫持攻击。

该响应头有三个值可选，分别是

- `DENY`,表示页面不允许通过`iframe`的方式展示
- `SAMEOPIGIN`,表示页面可以在相同域名下通过`iframe`的方式展示
- `ALLOW-FROM`,表示页面可以在指定来源的`iframe`中展示

## 4.中间人攻击

> 什么是中间人攻击？如何防范中间人攻击？

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共 Wi-Fi,因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。

## 前端安全问题

### 1.XSS：将代码注入网页中

- 持久型：攻击代码写入数据库
- 非持久型：一般通过修改 URL 参数的方式攻击，诱导用户点击链接

#### 防范：

- 转义字符
- 使用白名单（CSP）

  - 设置 HTTP Header 中的`Content-Security-Policy`
  - 设置`meta`标签的方式`<meta http-equiv="Content-Security-Policy">`

  CSRF：是跨站请求伪造，很明显根据刚刚的解释，他的核心也就是请求伪造，通过伪造身份提交 POST 和 GET 请求来进行跨域的攻击。

### 2.CSRF:跨站请求伪造

攻击者构造一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求，如果用过是在登录状态下的话，后端就一位是用户在操作

#### 防范

- Get 请求不对数据进行修改
- 不让第三方网站访问到用户 Cookie
- 阻止第三方网站请求接口
- 请求时附带验证信息，比如验证码或者 Token
- 可以对 Cookie 设置 Samesite:Cookie 不随着跨域请求发送
- referer

  **完成 CSRF 需要两个步骤：**

  1.登陆受信任的网站 A，在本地生成 COOKIE

  2.在不登出 A 的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站 B。

xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写

csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤

## 8.常见的 web 安全及防护原理

### 1.sql 注入原理：

通过 sql 命令插入到 web 表单提交或者输入活命，达到欺骗服务器执行的恶意 sql 命令

### 2.xss（跨站脚本攻击）：

往 web 页面插入恶意的 html 标签或者 js 代码

### 3.csrf(跨站请求伪造)：

通过伪装来自受信任用户的请求

### xss 和 csrf 的区别：

- 1.xss 是获取信息，不需要提前知道其他用户页面的代码和数据包
- 2.csrf 代替用户完成指定的动作，需要知道其他页面的代码和数据包