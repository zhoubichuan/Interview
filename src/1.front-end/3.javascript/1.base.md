---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 一.JS 基础知识点

## 1.原始类型

> 原始类型有那几种？null 是对象吗？
- 6种：undefined、null、string、boolean、number、symbol
- 原始类型存储的都是值，是没有函数可以调用的，能调用是因为被强制转换成了string类型，也就是对象类型 `'1'.toString()`,number是浮点类型的

typeof null
## 2.对象类型

> 对象类型和原始类型的不同之处？函数参数是对对象会发生什么问题？

原始类型存储在堆内存中，为值，修改不影响原来的值；对象类型存储在栈内存中，为引用地址，修改会影响原来的值
## 3.typeof vs instanceof

> typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？

- `typeof` 对于原始类型来说，除了`null`都可以显示正确的类型
- `typeof`对于对象来说，除了函数都会显示`object`,所以说`typeof`并不能准确判断变量到底是什么类型
- 如果我们想判断一个对象的正确类型，这时候可以考虑使用`instanceof`,因为内部机制是通过原型链来判断的
- 对于原始类型来说，你想直接通过`instanceof`来判断类型是不行的，当然我们还是有办法让`instanceof`判断原始类型的

  ```js
  class PrimitiveString {
    static [Symbol.hasInstance](x) {
      return typeof x === 'string'
    }
  }
  console.log('hello world' instanceof PrimitiveString) // true
  ```

  你可能不知道`Symbol.hasInstance`是什么东西，其实就是一个能让我们自定义`instanceof`行为的东西，以上代码等同于`typeof 'hello world' === 'string'`,所以结果自然是`true`了。这其实也侧面反映了一个问题，`instanceof`也不是百分百可信的。

## 4.类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

- 转换为布尔值
- 转换为数字
- 转换为字符串

| 原始值                | 转换目标 | 结果                                                 |
| --------------------- | -------- | ---------------------------------------------------- |
| number                | 布尔值   | 除了 0、-0、NaN 都为 true                            |
| string                | 布尔值   | 除了空字符串都为 true                                |
| undefined、null       | 布尔值   | false                                                |
| 引用类型              | 布尔值   | true                                                 |
| number                | 字符串   | 5=>'5'                                               |
| Boolean、函数、Symbol | 字符串   | 'true'                                               |
| 数组                  | 字符串   | [1,2]=>'1,2'                                         |
| 对象                  | 字符串   | '[object Object]'                                    |
| string                | 数字     | '1'=>1,'a'=>NaN                                      |
| 数组                  | 数字     | 空数组为 0，存在一个元素且为数字转数字，其他情况 NaN |
| null                  | 数字     | 0                                                    |
| 除了数组的引用类型    | 数字     | NaN                                                  |
| Symobl                | 数字     | 抛错                                                 |

> 对象转原始类型

对象在转换类型的时候，会调用内置的`[[ToPrimitive]]`函数，对于函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用`x.valueOf()`,如果转换为基础类型，就返回转换的值
- 调用`x.toString()`，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

当然你也可以重写`Symbol.toPrimitive`，该方法在转原始类型时调用优先级最高。

```js
let a = {
  valueOf(){
    return 0
  }
  toString(){
    return '1'
  }
  [Symbol.toPrimitive](){
    return 2
  }
}
1 + a // =>3
```

> 四则运算

加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

```js
1 + "1" //'11'
true + true //2
4 + [1, 2, 3] //'41,2,3'
```

> 比较运算符

1.如果是对象，就通过`toPrimitive`转换对象 2.如果是字符串，就通过`unicode`字符索引来比较

```js
let a = {
  valueOf(){
    return 0
  }
  toString(){
    return '1'
  }
}
a > 1 //true
```

在以上代码中，因为 A 是对象，所以通过`valueOf`转换为原始类型再比较值。

## 5.this

> 如何正确判断 this?箭头函数的 this 是什么?

## 6.== vs ===

> == 和 === 有什么区别？

对于`==`来说，如果对比双方的类型**不一样**的话，就会进行**类型转换**

假如我们需要对比`x`和`y`是否相同，就会进行如下判断流程：

1.首先会判断两者类型是否相同，相同的话就是比大小了

2.类型不相同的话，那么就会进行类型转换

3.首先会判断是否在比对`null`和`undefined`,是的话就会返回`true`

4.判断两者类型是否为`string`和`number`,是的话就会将字符串转换为`number`

```js
1 == "1" // 1 == 1
```

5.判断其中一方是否为`boolean`,是的话就会把`boolean`转为`number`再进行判断

```js
"1" == true // '1' == 1 --> 1==1
```

6.判断其中一方是否为`object`且另一方为`string`、`number`或者`symbol`，是的话就会把`object`转为原始类型再进行判断

```js
"1" == { name: "yck" } // '1' == '[object Object]'
```

## 7.闭包

> 什么是闭包

闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

```js
function A() {
  let a = 1
  window.B = function() {
    console.log(a)
  }
}
A()
B()
```

很多人对于闭包的解释可能就是嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。

## 8.深浅拷贝

> 什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？

一般我们用 Object.assign 和扩展运算符实现浅拷贝

通常可以用 JSON.parse(JSON.stringify(Obj))实现深拷贝

但是该方法有局限性：

- 忽略函数
- 忽略 undefined
- 忽略 symbol
- 不能序列化函数
- 不能解决循环引用的对象

也可以使用 MessageChannel 实现深拷贝

该方法有局限性：

- 不能拷贝函数

## 9.原型

> 如何理解原型？如何理解原型链？
## 1.并发和并行区别

> 并发与并行的区别

并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称为并行。

## 2.回调函数

> 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？

回调地狱的根本问题就是：

1.嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身

2.嵌套函数一多，就很难处理错误

当然回调函数还存在着别的几个缺点，比如不能用`try catch`捕获错误，不能直接`return`。

## 3.Generator

> 你理解的 Generator 是什么?

`Generator`最大的特点就是可以控制函数的执行。

## 4.Promise

> Promise 的特点是什么，分别有什么缺点?什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别?

promise 有三种状态：pending、resolved、rejected 这个承诺一旦从等待状态变为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后,就不能再改变

当我们在构造 promise 的时候，构造函数内部的代码是立即执行的

Promsie 实现了链式调用，很好地解决了回调地狱的问题，但是也有一些缺点比如无法取消 Promise，错误需要通过回调函数捕获。

## 5.async 及 await

> async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？

一个函数如果加上 async，那么这个函数就会返回一个 Promise

async 就是将函数返回值使用`Promise.resolve()`包裹了下，和`then`中处理返回值一样，并且`await`只能配套`async`用

`async`和`await`可以说是异步终极解决方案了，相比直接使用 `Promsie`来说，优势在于处理`then`的调用链，能够更清晰准确的写出代码，毕竟写一大堆`then`也很恶心，并且也能优雅的解决回调地狱问题。当然也存在一些缺点。因为`await`将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了`await`会导致性能上的降低。

其实`await`就是`generator`加上`Promise`的语法糖，且内部实现了自动执行`generator`。如果你熟系 co 的话，其实自己可以实现这样的语法糖。

## 6.常用定时器函数

> setTimeout、setInterval、requestAnimationFrame 各有什么特点？

异步编程当然少不了定时器了，常见的定时器函数有`setTimeout`、`setInterval`、`requsetAnimationFrame`。

因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致`setTimeout`不会按期执行。当然了，我们可以通过代码去修正`setTimeout`，从而使定时器相对准确。

接下来我们来看`setInterval`，其实这个函数作用和`setTimeout`基本一致，只是该函数是没隔一段时间执行一次回调函数。

通常来说不建议使用`setInterval`。第一，他和`setTimeout`一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题

如果你有循环定时器的需求，其实完全可以通过`requestAnimationFrame`来实现

首先`requsetAnimationFrame`自带函数节流的功能，基本可以保证在 16.6ms 内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现`setTimeout`
