---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# 浏览器基础知识点

## 1.事件机制

> 事件的触发过程是怎么样的？知道什么是事件代码吗？

### 事件触发三个阶段

- window 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册事件
- 从事件触发处往 window 传播，遇到注册的冒泡事件会触发

事件触发一般来说会按照上面的顺序进行，但是也有特例，**如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行**

```js
// 以下会先打印冒泡然后捕获
node.addEventListener(
  "click",
  (event) => {
    console.log("冒泡")
  },
  false
)
node.addEventListener("click", (event) => {
  console.log("捕获")
})
```

### 注册事件

通常我使用`addEventListener`注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值`useCapture`参数来说，该参数默认值为`false`,`useCapture`决定了注册的事件是捕获事件还是冒泡事件。对于对象来说，可以使用以下几个属性

- `capture` ：布尔值，和`useCapture`
- `once`: 布尔值，值为`true`表示该回调只会调用一次，调用后会移除监听
- `passive`:布尔值，表示永远不会调用`preventDefault`

一般来说，如果我们只希望事件只触发在目标上，这时候可以使用`stopPropagation`来阻止事件的进一步传播。通常我们认为`stopPropagation`是用来阻止事件冒泡的，其实该函数可以阻止捕获事件。`stopImmediatePropagation`同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。

```js
node.addEventListener(
  "click",
  (event) => {
    event.sotpImmediatePropagation()
    console.log("冒泡")
  },
  false
)
// 点击node只会执行上面的函数，该函数不会执行
node.addEventListener(
  "click",
  (event) => {
    console.log("捕获")
  },
  true
)
```

### 事件代理

如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话**应该注册在该父节点上**

```js
<ul id="ul">
	<li>1</li>
    <li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ul>
<script>
	let ul = document.querySelector('#ul')
	ul.addEventListener('click', (event) => {
		console.log(event.target);
	})
</script>
```

事件代理的方式相较于直接给目标注册事件来说，有以下优点：

- 节省内存
- 不需要给子节点注销事件

## 3.存储

> 有几种方式可以实现存储功能，分别有什么优缺点？什么是 Service Worker?
> **Cookie**、**localStorage**、**sessionStorage**、**indexDB**

### Service Worker

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到`install`事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询时候存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

```js
// install.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register("sw.js")
    .then(function (registration) {
      console.log("service worker 注册成功")
    })
    .catch(function (err) {
      console.log("service worker 注册失败")
    })
}
// sw.js
// 监听 `install`事件,回调中缓存所需文件
self.addEventListener("install", (e) => {
  e.waitUntil(
    caches.open("my-cache").then(function (cache) {
      return cache.addAll(["./index.html", "./index.js"])
    })
  )
})
// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener("fetch", (e) => {
  e.respondWith(
    caches.match(e.request).then(function (response) {
      if (response) {
        return response
      }
      console.log("fetch source")
    })
  )
})
```

## 6.什么是内存溢出和内存泄漏

给的不够用，用了不归还

- 内存溢出：
  - 在程序申请内存是，没有足够的内存空间供其使用，出现 out of memoryp;比如申请了一个 integer，但是给他存了 long 才能存下的数据，那就是内存溢出。
- 内存泄漏：
  - 在程序申请内存后，无法释放已申请的内存空间，一次内存泄漏的危害可以忽略，但是内存泄漏堆积的后果很严重，无论多少内存，迟早会被占光
  - 内存泄漏会导致一系列问题，比如：运行缓慢，崩溃，高延迟
- 哪些操作会造成内存泄漏
  - 闭包中的 this，对象函数
  - 匿名函数返回函数
  - setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏
