# node 部分

## 1.状态吗

* 2xx 成功处理了请求状态
  * 200 服务器已经成功处理请求，并提供了请求的网页
  * 201 用户新建或修改数据成功
  * 202 一个请求已经进入后台
  * 204 用户删除成功
* 3xx 每次请求使用的重定向不要超过 5 次
  * 304 网页上请求没有更新，节省宽带和开销
* 4xx 表示请求可能出错，妨碍了服务器的处理
  * 400 服务器不理解请求的语法
  * 401 用户没有权限（用户名，密码输入错误）
  * 403 用户得到授权（401 相反），但是访问被禁止
  * 404 服务器找不到请求的网页
* 5xx 表示服务器在处理请求的时候发生内部错误
  * 500 服务器遇到错误，无法完成请求
  * 503 服务器目前无法使用（超载或停机维护）

## 2.304 的缓存原理（添加 Etag 标签。last-modified）304 网页上次请求没有更新，节省宽带和开销

* 1.服务器首先产生 Etag，服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该几号传回服务器要求服务器验证（客户端）缓存
* 2.304 是 http 的状态吗，服务器用来标识这个文件有没有修改，不返回内容，浏览器接到这个状态码会去找浏览器缓存的文件
* 3.流程：客户端请求一个页面 A，服务器返回页面 A，并在 A 上加一个 Tage 客户端渲染该页面，并把 Tage 也存储在缓存中。客户端再次请求页面 A 并将上次请求的资源和 ETage 一起传递给服务器。服务器检查 Tage，并判断出该页面自上次客户端请求之后未被修改，直接返回 304
  * last-modified：客户端请求资源，同时有一个 last-modified 的属性标记此文件在服务器最后修改的时间，根据 http 协议。浏览器会向服务器发送一个 if-modified-since 报头，询问该事件之后文件是否被修改，没有修改返回 304
  - 有了 last-modified，为什么还要用 Etag?
    * 1.因为如果在一秒钟之内对一个文件进行两次更改，last-modified 就会不正确（last-modified 不能识别秒单位的修改）
    * 2.某些服务器不能精确的得到文件的最后修改时间
    * 3.一些文件也会周期性的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新 get
  - 有 Etag，为什么还要用 last-modified
    * 1.两者互不，Etag 的判断的缺陷，比如一些图片等静态文件的修改
    * 2.如果每次扫描内容都生成 Etag 比较，显然要比直接比较修改时间慢的多
  - Etag 是被请求变量的实体值（文件的索引节大小和最后修改的时间的 hash 值）
  - 1.Etag 的值服务器端对文件的索引节，大小和最后的修改的事件进行 hash 后得到

## 3.get/post 的区别

* 1.get 数据是存放在 url 之后，以？分割 url 和传输数据，参数之间以&相连；post 方法是把提交的数据放在 http 包的 body 中
* 2.get 提交的数据大小有限制，（因为浏览器对 url 的长度有限制），post 的方法提交的数据没有限制
* 3.get 需要 request.queryString 来获取变量的值，而 post 方式通过 request。form 来后期变量的值
* 4.get 的方法提交数据，会带来安全问题，比如登录一个页面，通过 get 方式提交数据，用户名和密码就会出现在 url 上

## 4.http 协议的理解

* 1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议
* 2.基于 TCP/IP 通信协议传递数据（HTML,图片资源）
* 3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统
* 4.http 请求信息 request:
  * 请求行（request line）、请求头部（header）、空行和请求数据四个部分构成
  * 请求行，用来说明请求类型，要访问的资源以及所使用的 http 版本
  * 请求头部，用来说明服务器要使用的附加信息
  * 空行，请求头部后面的空行是必须的
  * 请求数据也叫主体，可以添加任意的其他数据
* 5.http 相应信息 response
  * 状态行、消息报头、空行和响应正文
  * 状态行、有 http 协议版本号，状态吗，状态消息 三部分组成
  * 消息报头，用来说明客户端要使用的一些附加信息
  * 空行，消息报头后面的空行是必须的
  * 响应正文，服务器返回给客户端的文本信息

## 5.http 和 https

* https：是以安全为目标的 http 通道，简单讲是 http 的安全版本，通过 ssl 加密
* http：超文本传输协议。是一个客户端和服务器请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少
## 6.http1.0和http2.0的区别
- 长连接：http1.0需要使用keep-alive参数来告知服务器建立一个长连接，而http1.1默认支持长连接
- 节约宽带：http1.1支持只发送一个header信息（不带任何body信息）
- host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：http1.0没有host域
- 1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好
- 2.数据压缩：对信息头采用了hpack进行压缩传输，节省了信息头带来的网络流量
- 3.多路复用：一个连接可以并发处理多个请求
- 4.服务器推送：我们对支持http2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取，这种方式非常适合加载静态资源
## 7.web缓存
- 1.web缓存就是存在于客户端与服务器之间的一个副本，当你发出第一个请求后，缓存根据请求保存输出内容副本
- 2.缓存的好处
    - 1.减少不必要的请求
    - 2.降低服务器的压力，减少服务器的消耗
    - 3.降低网络延迟，加快页面打开速度（直接读取浏览器的数据）
## 8.常见的web安全及防护原理
- 1.sql注入原理：通过sql命令插入到web表单提交或者输入活命，达到欺骗服务器执行的恶意sql命令
- 2.xss（跨站脚本攻击）：往web页面插入而已的html标签或者js代码
- 3.csrf(跨站请求伪造)：通过伪装来自受信任用户的请求
- xss和csrf的区别：
    - 1.xss是获取信息，不需要提前知道其他用户页面的代码和数据包
    - 2.csrf代替用户完成指定的动作，需要知道其他页面的代码和数据包
## 9.cdn（内容分发网络）
- 1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定
- 2.关键技术：内容存储和分发技术中
- 3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术奖用户的访问指向距离最近的缓存服务器，有缓存服务器直接响应用户的请求（全局负载技术）
## 10.tcp三次握手（客户端和服务端都需要确认各自可收发）
- 客户端c发起请求连接服务器端s确认，服务器端也发起连接确认客户端的确认
- 第一次握手：客户端发送一个请求连接，服务端只能确认自己可以接受客户端发送的报文段
- 第二次握手：服务端向客户端发送一个连接，确认客户端收到自己发送的报文段
- 第三次握手：服务器端确认客户端收到了自己发送的报文段

## 11.从输入url到获取页面的完整过程
https://blog.csdn.net/samjustin1/article/details/52650520
- 1.查询dns（域名解析），获取域名对应的ip地址 查询浏览器缓存
- 2.浏览器与服务器建立tcp连接（三次握手）
- 3.浏览器向服务器发送http请求（请求和传输数据）
- 4.服务器接受这个请求后，根据路径参数，经过后端的一些处理生成html代码返回给了浏览器
- 5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js,图片和上面一样的步骤
- 6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来
## 12.浏览器渲染原理及流程 
- dom --> cssom -->render-->layout -->print
- 流程：解析html以及构建dom树 -->构建render树 -->布局render树 -->绘制render树
- 概念：
    - 1.构建dom树：渲染引擎解析html文档，首先将标签转换为dom树中的dom node（包括js生成的标签）生成内容树
    - 2.构建渲染树：解析对应的css样式文件信息（包括js生成的样式和外部的css）
    - 3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置
    - 4.绘制渲染树：遍历渲染树，使用ui后端层来绘制每一个节点
    - 重绘：当盒子的位置，大小以及其他属性，例如颜色，字体大小等的确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上，触发重绘的条件：改变元素的外观属性，如：color，background-color；重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现出新的外观
    注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花时间，要尽量避免使用table布局
    - 重排：（重构/回流/reflow）：当渲染树中的一部分（或者全部）因为元素的规模尺寸，布局，影藏等改变而需要重新构建，这就是回流；每个页面都需要一次回流，就是页面第一次渲染的时候
    重排一定会影响重绘，但是重绘不一定会影响重排
## 13.为什么css妨碍顶部而js写在后面
- 1.浏览器预先加载css后，可以不必等待html加载完毕就可以渲染页面到了
- 2.其实html渲染并不会等到完全加载完在渲染页面，而是一遍解析dom一遍渲染
- 3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更快加载，提高用户的良好体验
- 4.但是随着js技术的发展，js也开始承担页面渲染的工作，比如我们的ui其实可以分别对待，把渲染页面的js放到前面，时间处理的js放到后面

## 14.存储方式与传输方式
- 1.indexDB：是h5的本地存储库，把一些数据存储到浏览器总，没由网络，浏览器可以从这里读取数据，离线运用
- 2.Cookie ：通过浏览器记录信息确认用户的身份，最大4kb，这也就限制了传输的数据，请求的性能会受到影响
- 3.Session:服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客户端，保存为cookie）
- 4.localStorage:h5的本地存储，数据永久保存在客户端
- cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上；实际上浏览器和服务器之间仅需传递session对象，session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据
- cookie数据始终在同源的http请求中携带，在浏览器服务器来回传递，里面存放着session_id
- sessionStorage,localStorage仅在本地保存
- 大小限制区别，cookie数据不超过4kb,localStorage在谷歌浏览器中2.6MB
- 数据有效期不同，cookie在设置（服务器设置）有效期内有效，不管窗口和浏览器关闭
sessionStorage尽在当前浏览器窗口关闭有效，关闭即销毁（临时存储）
localStorage始终有效
- sessionStorage和localStorage区别：
    - 1.sessionStorage用本地存储一个会话中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中）
    - 2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期
- token cookie session三者的理解
    - 1.token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件（最好的身份认证，安全性好，而且是唯一的）用户身份的验证方式
    - 2.cookie是写在客户端的一个txt文件，里面包括登录信息之类的，这样你下次登录某个网站，就会自动调用cookie自动登录用户名
    服务器生成，发送到浏览器 浏览器保存  下次请求再次发送给服务器（存放着登录信息）
    - 3.session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）
    cookie中存放着sessionID,请求会发送这个id，session因为request对象而产生
    - 基于token的身份验证：（嘴贱点的token：uid用户唯一的身份识别+time当前时间戳+sign签名）
      - 1.用户通过用户名和密码发送请求
      - 2.服务器端验证
      - 3.服务器端返回一个带签名的token,给客户端
      - 4.客户端存token，并且每次用于发送请求
      - 5.服务器验证token并且返回数据 每一请求都需要token
    - cookie和session区别
      - 1.cookie数据存放在客户的浏览器上，session数据存放在服务器上
      - 2.cookie不是很安全，别人可以分析存放本地的cookie并进行cookie欺骗，考虑到安全应当使用session
      - 3.session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie
      - 4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
    - session与token区别
      - 1.sessio认证只是把简单大的urser的信息存储session里面，sessionID不可预测，一种认证手段，只存在服务端，不能共享到其他的网站和第三方app
      - 2.token是oAuth Token,目的就是让某app有权访问某用户的信息，token是唯一的；token不能转移到其他的app，也不能转到其他用户上（使用于app）
      - 3.session的状态是存在服务端的，客户单只存在session id ，token装填是存储在客户端的
    - cookie的弊端有哪些
      - 优点：保存客户端数据，分担了服务器存储的负担
      - 1.数量和长度的限制，每个特定的域名下最多生成20个cookie（chorme和safari没有限制）
      - 2.安全性问题
      