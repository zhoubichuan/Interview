## 1.两个栈实现一个队列，两个队列实现一个栈

* https://www.cnblogs.com/MrListening/p/5697459.html

## 2.红黑树（解决二叉树依次插入多个节点时的线性排列）

* https://juejin.im/post/5a27c6946fb9a04509096248

## 3.最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）

* https://juejin.im/post/5a2ff8c651882533d0230a85

## 4.十大排序

* 1.  冒泡排序
  * 重复走访要排序的数列，依次比价两个元素，如果他们的顺序错误就把他们交换过来
  * 实现过程
    * 1.比较相邻的元素，如果第一个比第二个大，就交换他们两个
    * 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会使最大的数
    * 3.针对所有的元素重复以上的步骤，除了最后一个
    * 4.重复步骤 1-3,直到排序完成

- 2.选择排序
  * 首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在排序序列的末尾
  * 实现过程
- 3.插入排序
  * 构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置插入
  * 实现过程
    * 1.从第一个元素开始，该元素可以认为已经被排序
    * 2.取出下一个元素，在已排序的元素序中从后向前扫描
    * 3.如果该元素（已排序）大于新元素，将元素向后移一位
    * 4.在取出一个元素，比较之前的，知道找到自己合适的位置
- 4.桶排序
  * 将数据分布到有限数量的桶里，每个桶再分别排序
- 5.快速排序
  * 快速排序使用分治法把一个串（list）分成两个子串（sub-lists）
  * 实现过程
    * 1.从数组中挑出一个元素，成为一个基准
    * 2.重新排序数组，所有元素比基准小的摆在基准前面，所有比基准大的摆在基准后面，这个分区退出之后，该基准就处于数列的中间位置，成为分区操作
    * 3.递归的把小于基准值的子数列和大于基准元素的子数列排序
    ```
    function quickSory(arr){
        if(arr.length <=1>){
            return false
        }
        var destIndex=Math.floor(arr.length/2)
        var left=[],right=[]
        var dest=arr.splice(destIndex,1)[0]
        for(var i=0;i<arr.length;i++>){
            if(arr[i]<dest){
                left.push(arr[i])
            }else{
                right.push(arr[i])
            }
        }
        return quickSort(left).concat([dest],quickSort(right))
    }
    ```
- 6.堆排序
  * 利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点
  * 实现过程

## 5.数组去重

* 1.双重循环
* 2.indexOf
* 3.数组排序去重 最快

## 6.字符串

* 判断回文子符串：（递归的思想）
  * 1.字符串分割，倒转，聚合

```
[...obj].reverse().join('')
```

* 2.字符串头部和尾部，逐次向中间检查

```
function isPalindrome(line){
    line +=''
    for(var i=0,j=line.length-1;i<j;i++,j--){
        if(line.chartAt(i) !==line.chartAt(j)){
            return false
        }
    }  
}
```

* 3.递归

## 7.二分查找（有序数组的查找）

* 二分查找可以解决已排序数组的查找问题，即只要数组中包含 T（要查找的值），那么通过不断的缩小包含 T 的数据范文，就可以找到最终要找到的数
* 1.一开始，数据范围覆盖整个数组
* 2.将数组的中间项与 T 进行比较，如果 T 比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分查找
* 3.就这样，每次查找都可以排除一半元素，相当于范围缩小一半，这样反复比较，反复缩小范围，最终会在数组中找到 T

```
function binarySearch(data,dest,start,end){
    var end= end||data.length-1
    var start= start||0
    var m= Math.floor((start+end)/2)
    if(dest<data[m]){
        return binarySearch(data,dest,0,m-1)
    }else if(dest>data[m]){
        return binarySearch(data,dest,m+1,end)
    }else{
        return data[m]
    }
}
```
