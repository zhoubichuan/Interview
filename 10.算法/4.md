## 4. 十大排序

* 1.  冒泡排序
  * 重复走访要排序的数列，依次比价两个元素，如果他们的顺序错误就把他们交换过来
  * 实现过程
    * 1.比较相邻的元素，如果第一个比第二个大，就交换他们两个
    * 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会使最大的数
    * 3.针对所有的元素重复以上的步骤，除了最后一个
    * 4.重复步骤 1-3,直到排序完成

- 2.选择排序
  * 首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在排序序列的末尾
  * 实现过程
- 3.插入排序
  * 构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置插入
  * 实现过程
    * 1.从第一个元素开始，该元素可以认为已经被排序
    * 2.取出下一个元素，在已排序的元素序中从后向前扫描
    * 3.如果该元素（已排序）大于新元素，将元素向后移一位
    * 4.在取出一个元素，比较之前的，知道找到自己合适的位置
- 4.桶排序
  * 将数据分布到有限数量的桶里，每个桶再分别排序
- 5.快速排序
  * 快速排序使用分治法把一个串（list）分成两个子串（sub-lists）
  * 实现过程
    * 1.从数组中挑出一个元素，成为一个基准
    * 2.重新排序数组，所有元素比基准小的摆在基准前面，所有比基准大的摆在基准后面，这个分区退出之后，该基准就处于数列的中间位置，成为分区操作
    * 3.递归的把小于基准值的子数列和大于基准元素的子数列排序
    ```
    function quickSory(arr){
        if(arr.length <=1>){
            return false
        }
        var destIndex=Math.floor(arr.length/2)
        var left=[],right=[]
        var dest=arr.splice(destIndex,1)[0]
        for(var i=0;i<arr.length;i++>){
            if(arr[i]<dest){
                left.push(arr[i])
            }else{
                right.push(arr[i])
            }
        }
        return quickSort(left).concat([dest],quickSort(right))
    }
    ```
- 6.堆排序
  * 利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点
  * 实现过程
