## 16.深拷贝和浅拷贝

- 基本类型：undefined,null,Boolean,String,Number,Symbol 在内存中占据固定大小，保存在栈内存中

* 引用数据类型：Object,Array,Date,Function,RegExp 等；引用数据类型的值是对象，保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。
* 基本数据类型的复制：其实就是创建一个新的副本给这个值赋值新的变量，改变旧值对象不会改变
* 引用数据类型：其实就是复制了指针，这个最终都将指向同一个对象，改变其新对象旧的值也会改变
* 基本类型的比较 == 会进行类型转换
* 浅拷贝：仅仅只是复制了引用，彼此操作不影响，slice concat object.assign
* 深拷贝：在堆中重新分配内存，不同的地址，相同的值，互不影响
* JSON.parse()将一个 js 对象序列化一个 json 字符串 JSON.stringify()将 json 字符串反序列化一个 js 对象

```
var obj={key:{key:1}}
var obj2 = JSON.parse(JSON.stringify(obj))
```

- es6 的展开

```
{...}
```

### 深拷贝和浅拷贝的主要区别是：

在内存中的存储类型不同：

- 浅拷贝：重新在堆栈中创建内存，拷贝前后对象的基本类型互不影响。只拷贝一层，不能对对象的子对象进行拷贝
- 深拷贝：对对象中的子对象进行递归拷贝，拷贝前后两个对象互不影响

深拷贝和浅拷贝是只针对 Object 和 Array 这样的复杂类型的
也就是说 a 和 b 指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝
浅拷贝， ”Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象
深拷贝，JSON.parse()和 JSON.stringify()给了我们一个基本的解决办法。但是函数不能被正确处理
