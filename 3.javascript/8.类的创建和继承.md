## 8. 类的创建和继承
- 原型链继承
- 构造函数继承
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生组合继承
- 混合继承
- es6继承

### 1·原型链继承
```js
function Parent(){
    this.parentName='parent'
}
Parent.portotype.getParentName=function(){
    return this.parentName+1
}
function Child(){
    this.name='child'
}
Child.prototype=new Parent()
Child.prototype.getChildName=function(){
    return this.name+1
}
var child=new Child()
console.log(child.getParentName())
```
### 2.构造函数继承
```js
function Parent(){
    this.parentName='parent'
}
Parent.prototype.getParentName=function(){
    return this.parentName+1
}
function Child(){
    this.name='child'
    Parent.call(this)
}
Child.prototype.getChildName=function(){
    return this.name+1
}
var child= new Child()
console.log(child.parentName)
```
### 3.组合继承
```js
function Parent(){
    this.parentName='parent'
}
Parent.prototype.getParentName=function(){
    return this.parentName+1
}
function Child(){
    this.name='child'
    Parent.call(this)
}
Child.prototype=new Parent()
Child.prototype.getChildName=function(){
    return this.name+1
}
var child= new Child()
console.log(child.getParentName())
console.log(child.parentName)
```
### 4.原型式继承
```js
function Parent(){
    this.parentName='parent'
}
Parent.prototype.getParentName=function(){
    return this.parentName+1
}
function object(obj){
    function F(){}
    F.prototype=obj
    return new F()
}
var child=object(new Parent())
child.childName="child"
child.getChildName=function(){
    this.childName+1
}
console.log(child.getChildName())
```
### 5.寄生式继承
```js
function Parent(){
    this.parentName='parent'
}
Parent.portotype.getParentName=function(){
    return this.parentName+1
}
function createAnother(original){
    var clone=Object(original)
    clone.childName='child'
    clone.getChildName=function(){
        return this.childName+1
    }
    return clone
}
var child =createAnother(new Parent())
child.prototype=new Parent()
console.log(child.parentName)
```
### 6.寄生组合继承
```js
function inheritPrototype(c,p){
    var prototype=Object.create(p.ptototype)
    prototype.constructor=c
    c.prototype=prototype
}
function Parent(){
    this.parentName='parent'
}
Parent.prototype.getParentName=function(){
    return this.parentName+1
}
function Child(){
    this.childName='child'
    Parent.call(this)
}
inheritPrototype(Child,Parent)
Child.prototype.getChildName=function(){
    return this.childName+1
}
var child=new Child()
console.log(child.parentName)
console.log(child.getParentName())
```
### 7.混合式继承
```js
function Parent(){
    this.parentName='parent'
}
Parent.portotype.getParentName=function(){
    return this.parentName+1
}
function Child(){
    this.name='child'
}
Child.prototype.getChildName=function(){
    return this.name+1
}
function MyClass(){
    Parent.call(this)
    Child.call(this)
}
MyClass.prototype=Object.create(Parent.prototype)
Object.assign(MyClass.prototype,Child.prototype)
MyClass.prototype.constructor=MyClass
var child=new MyClass()
console.log(child.getParentName())
```
### 8.es6中继承
```js
class Parent{
    constructor(){
        this.parentName='parent'
    }
    getParentName(){
        return this.parentName+1
    }
}
class Child extends Parent{
    constructor(){
        super()
        this.childName='child'
    }
    getChildName(){
        return this.childName+1
    }
}
var child= new Child()
console.log(child.getChildName())
```